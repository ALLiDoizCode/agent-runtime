# Story 20.11: Payment Escrow Integration

## Status

Draft

## Story

**As a** coordinator agent orchestrating multi-agent workflows,
**I want** to require stake payments from participants that are held in escrow until the coordination outcome is determined,
**so that** participants have skin in the game and escrow funds are automatically released or refunded based on the proposal outcome.

## Acceptance Criteria

1. Proposals can require stake from participants
2. Stakes held in escrow until outcome
3. Approved proposals release escrow to recipient
4. Rejected proposals refund stakes
5. Expired proposals refund stakes
6. Stake amounts configurable per proposal

## Tasks / Subtasks

- [ ] Task 1: Extend Proposal types with stake fields (AC: 1, 6)
  - [ ] Update `Proposal` interface in `packages/connector/src/agent/coordination/types.ts`
  - [ ] Add `stakeRequired?: bigint` field (optional stake amount in smallest unit)
  - [ ] Add `escrowAddress?: string` field (ILP address for escrow, generated if stake required)
  - [ ] Add `stakes?: Map<string, bigint>` field (tracks participant pubkey → staked amount)
  - [ ] Update `CreateProposalParams` interface to include `stakeRequired?: bigint` parameter
  - [ ] Add TAG_STAKE constant: `export const TAG_STAKE = 'stake';`
  - [ ] [Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.11 line 726-730, packages/connector/src/agent/coordination/types.ts - Proposal interface]

- [ ] Task 2: Update ProposalCreator to support stake tags (AC: 1, 6)
  - [ ] Modify `ProposalCreator.buildTags()` method
  - [ ] If `params.stakeRequired` is defined, add stake tag: `[TAG_STAKE, stakeRequired.toString()]`
  - [ ] Generate escrow ILP address when stake required: `${this.ilpAddress}.escrow.${proposalId}`
  - [ ] Store escrow address in proposal metadata (consider adding to tags or content)
  - [ ] Update `ProposalCreator.create()` method to accept optional `stakeRequired` in params
  - [ ] [Source: packages/connector/src/agent/coordination/proposal.ts - buildTags method, architecture/agent-society-protocol.md - ILP addressing]

- [ ] Task 3: Update ProposalParser to parse stake tags (AC: 1)
  - [ ] Modify `ProposalParser.parse()` method to extract stake tag
  - [ ] Parse `stakeRequired` from TAG_STAKE as bigint using `BigInt(tag[1])`
  - [ ] Initialize empty `stakes` Map if `stakeRequired` is present
  - [ ] Extract `escrowAddress` from proposal metadata or reconstruct from proposal ID
  - [ ] Validate stake amount is positive if present
  - [ ] [Source: packages/connector/src/agent/coordination/proposal-parser.ts - parse method]

- [ ] Task 4: Create EscrowCoordinator class (AC: 2, 3, 4, 5)
  - [ ] Create `packages/connector/src/agent/coordination/escrow-coordinator.ts`
  - [ ] Import required types: `Proposal`, `CoordinationOutcome`, `bigint` utilities
  - [ ] Import ILP payment types and utilities (from wallet or settlement modules)
  - [ ] Define `EscrowCoordinatorConfig` interface:
    - [ ] `ilpAddress: string` (agent's ILP address for generating escrow addresses)
    - [ ] `logger: Logger` (Pino logger for structured logging)
  - [ ] Create `EscrowCoordinator` class with constructor accepting config
  - [ ] Implement `generateEscrowAddress(proposalId: string): string` method
    - [ ] Return `${this.config.ilpAddress}.escrow.${proposalId}`
  - [ ] Note: Actual payment handling integration deferred - this story focuses on data model and outcome logic
  - [ ] [Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.11 line 742-761, architecture/agent-society-protocol.md - ILP addressing]

- [ ] Task 5: Implement requireStake method (AC: 1, 2)
  - [ ] Add `requireStake(proposal: Proposal, amount: bigint): Promise<void>` method to EscrowCoordinator
  - [ ] Generate escrow address using `generateEscrowAddress(proposal.id)`
  - [ ] Store escrow address in proposal (update proposal object in-place)
  - [ ] Initialize `proposal.stakes` Map if not present
  - [ ] Log escrow creation with structured logging: `{ proposalId, amount, escrowAddress }`
  - [ ] Note: This method prepares escrow metadata. Actual payment tracking deferred to future epic.
  - [ ] Return immediately (no blockchain integration yet - placeholder for future ILP payment monitoring)
  - [ ] [Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.11 line 743-749]

- [ ] Task 6: Implement releaseEscrow method (AC: 3, 4, 5)
  - [ ] Add `releaseEscrow(proposal: Proposal, outcome: CoordinationOutcome): Promise<void>` method
  - [ ] Validate proposal has `stakeRequired` and `stakes` fields
  - [ ] Implement outcome-based logic:
    - [ ] If outcome === 'approved': Log "Escrow release to recipient" (payment logic deferred)
    - [ ] If outcome === 'rejected' OR outcome === 'expired': Log "Escrow refund to participants" (payment logic deferred)
    - [ ] If outcome === 'inconclusive': Log "Escrow refund to participants" (payment logic deferred)
  - [ ] Clear `proposal.stakes` Map after processing (mark as released/refunded)
  - [ ] Log escrow resolution with structured logging: `{ proposalId, outcome, escrowAddress, stakeCount }`
  - [ ] Note: This story implements outcome determination logic. Actual ILP payment execution deferred to future epic integrating with AgentWallet or SettlementCoordinator.
  - [ ] [Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.11 line 751-760]

- [ ] Task 7: Integrate EscrowCoordinator with ResultAggregator (AC: 3, 4, 5)
  - [ ] Modify `ResultAggregator` class in `packages/connector/src/agent/coordination/result-aggregator.ts`
  - [ ] Add optional `escrowCoordinator?: EscrowCoordinator` to ResultAggregatorConfig
  - [ ] Update `ResultAggregator.create()` method to call escrow logic after determining outcome
  - [ ] After outcome determination, check if `proposal.stakeRequired` exists
  - [ ] If escrow required, call `await this.escrowCoordinator?.releaseEscrow(proposal, outcome)`
  - [ ] Log escrow integration with structured logging
  - [ ] [Source: packages/connector/src/agent/coordination/result-aggregator.ts - create method]

- [ ] Task 8: Update propose_coordination skill to support stake parameter (AC: 1, 6)
  - [ ] Modify `ProposeCoordinationParams` Zod schema in `propose-coordination-skill.ts`
  - [ ] Add optional `stakeRequired: z.string().optional().describe('Required stake amount in smallest unit (e.g., satoshis)')`
  - [ ] Parse `stakeRequired` string to bigint in execute function: `const stake = params.stakeRequired ? BigInt(params.stakeRequired) : undefined`
  - [ ] Pass stake to ProposalCreator.create() via CreateProposalParams
  - [ ] Update skill description to mention optional stake requirement parameter
  - [ ] [Source: packages/connector/src/agent/ai/skills/propose-coordination-skill.ts]

- [ ] Task 9: Create comprehensive unit tests for EscrowCoordinator (AC: 1-6)
  - [ ] Create `packages/connector/src/agent/coordination/__tests__/escrow-coordinator.test.ts`
  - [ ] Import test dependencies: Jest, EscrowCoordinator, test proposal factory
  - [ ] Create mock logger with jest.fn() for info, error methods
  - [ ] Create test config with mock ILP address (e.g., 'g.agent-test')
  - [ ] Test escrow address generation (AC: 1):
    - [ ] Verify `generateEscrowAddress('proposal123')` returns 'g.agent-test.escrow.proposal123'
  - [ ] Test requireStake method (AC: 1, 2):
    - [ ] Create proposal with stakeRequired
    - [ ] Call `requireStake(proposal, 1000n)`
    - [ ] Verify proposal.escrowAddress set correctly
    - [ ] Verify proposal.stakes Map initialized
    - [ ] Verify logger.info called with escrow creation details
  - [ ] Test releaseEscrow for approved outcome (AC: 3):
    - [ ] Create proposal with stakes Map containing participant entries
    - [ ] Call `releaseEscrow(proposal, 'approved')`
    - [ ] Verify logger.info called with "release to recipient" message
    - [ ] Verify stakes Map cleared after release
  - [ ] Test releaseEscrow for rejected outcome (AC: 4):
    - [ ] Call `releaseEscrow(proposal, 'rejected')`
    - [ ] Verify logger.info called with "refund to participants" message
  - [ ] Test releaseEscrow for expired outcome (AC: 5):
    - [ ] Call `releaseEscrow(proposal, 'expired')`
    - [ ] Verify logger.info called with "refund to participants" message
  - [ ] Test releaseEscrow for inconclusive outcome:
    - [ ] Call `releaseEscrow(proposal, 'inconclusive')`
    - [ ] Verify refund logic triggered
  - [ ] Test releaseEscrow with proposal without stake:
    - [ ] Call with proposal missing stakeRequired field
    - [ ] Verify no-op behavior (no error, just return)
  - [ ] Use AAA pattern (Arrange, Act, Assert) for all tests
  - [ ] Achieve >80% code coverage
  - [ ] [Source: architecture/test-strategy-and-standards.md - unit test requirements]

- [ ] Task 10: Create integration tests for staked coordination flow (AC: 1-6)
  - [ ] Create `packages/connector/test/integration/staked-coordination.test.ts`
  - [ ] Test full flow: create staked proposal → vote → result with escrow resolution
  - [ ] Create test scenario with 3 agents, stakeRequired=1000 satoshis
  - [ ] Verify ProposalCreator includes stake tag in event
  - [ ] Verify ProposalParser extracts stake correctly
  - [ ] Verify EscrowCoordinator.releaseEscrow called with correct outcome
  - [ ] Test approved outcome triggers "release to recipient" log
  - [ ] Test rejected outcome triggers "refund to participants" log
  - [ ] Test expired proposal triggers refund log
  - [ ] Verify escrow address format: `{ilpAddress}.escrow.{proposalId}`
  - [ ] [Source: architecture/test-strategy-and-standards.md - integration test requirements]

- [ ] Task 11: Update coordination types tests (AC: 1, 6)
  - [ ] Modify `packages/connector/src/agent/coordination/types.test.ts`
  - [ ] Add test cases for proposals with stakeRequired field
  - [ ] Verify bigint serialization/deserialization
  - [ ] Test edge cases: zero stake, very large stake (MAX_SAFE_INTEGER equivalent for bigint)
  - [ ] [Source: packages/connector/src/agent/coordination/types.test.ts]

- [ ] Task 12: Run tests and verify (AC: 1-6)
  - [ ] Run `npm test -- escrow-coordinator.test.ts` in connector package
  - [ ] Verify all escrow coordinator tests pass
  - [ ] Run `npm test -- staked-coordination.test.ts` for integration tests
  - [ ] Verify integration flow works end-to-end
  - [ ] Run `npm test -- coordination` to verify no regressions in coordination module
  - [ ] Check coverage meets 80% requirement
  - [ ] Fix any TypeScript strict mode errors
  - [ ] Fix any ESLint errors
  - [ ] [Source: architecture/test-strategy-and-standards.md]

## Dev Notes

### Previous Story Insights (20.10)

From Story 20.10 Dev Agent Record:

- Factory function pattern with dependency injection (privateKey, logger)
- 100% test coverage achieved (exceeds 80% requirement)
- TypeScript strict mode compliance - no any types, proper Logger typing
- Zod schema validation with .parse() for robust parameter checking
- EventHandlerResult return type with success/failure and F99 error codes
- Structured logging with Pino for observability
- Extension of event-database to support #d tag filtering
  [Source: docs/stories/20.10.story.md#dev-agent-record]

### Epic 20 Coordination Architecture Overview

Multi-agent coordination protocol enables agents to collectively decide on actions through proposals, votes, and result aggregation. Story 20.11 extends this with financial incentives.

**Coordination Lifecycle (with Escrow):**

1. **Proposal Creation** (Story 20.9): Coordinator creates Kind 5910 with optional stake requirement
2. **Stake Requirement** (Story 20.11 - this story): If stake required, generate escrow address and track stakes
3. **Voting** (Story 20.10): Participants vote on proposal (optionally after staking)
4. **Result Aggregation** (Story 20.8): Coordinator evaluates votes and determines outcome
5. **Escrow Resolution** (Story 20.11 - this story): Based on outcome, release or refund stakes

**Key Components:**

- **EscrowCoordinator**: New class managing stake requirements and escrow resolution
- **ProposalCreator**: Extended to include stake tags in Kind 5910 events
- **ProposalParser**: Extended to extract stake metadata from events
- **ResultAggregator**: Integrated with EscrowCoordinator to trigger escrow resolution

[Source: docs/prd/epic-20-multi-agent-coordination.md - Epic overview, packages/connector/src/agent/coordination/]

### Escrow Addressing Strategy

ILP addressing hierarchy for escrow accounts:

**Format:** `{agentIlpAddress}.escrow.{proposalId}`

**Example:**

- Agent ILP address: `g.alice.agent`
- Proposal ID: `abc123def456`
- Escrow address: `g.alice.agent.escrow.abc123def456`

**Rationale:**

- Hierarchical addressing per RFC-0015
- Escrow addresses namespaced under agent's ILP address
- Proposal ID ensures uniqueness per coordination
- Future integration: Escrow addresses can be monitored for ILP Prepare packets representing stake payments

[Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.11 line 745, architecture/agent-society-protocol.md - ILP addressing]

### Stake Data Model

**Proposal Extensions:**

```typescript
interface Proposal {
  // Existing fields...
  id: string;
  type: CoordinationType;
  participants: string[];
  // ...

  // New fields for Story 20.11
  stakeRequired?: bigint; // Required stake amount (optional)
  escrowAddress?: string; // ILP escrow address (generated if stake required)
  stakes?: Map<string, bigint>; // Participant pubkey → staked amount
}
```

**CreateProposalParams Extension:**

```typescript
interface CreateProposalParams {
  // Existing fields...
  type: CoordinationType;
  participants: string[];
  // ...

  // New field for Story 20.11
  stakeRequired?: bigint; // Optional stake requirement
}
```

**Nostr Event Tags:**

- New TAG_STAKE tag: `['stake', '1000']` (stake amount as string, bigint converted)
- Stored in Kind 5910 proposal events alongside existing tags (type, p, threshold, etc.)

**Stakes Map:**

- Key: Participant pubkey (hex string)
- Value: Staked amount (bigint)
- Populated when participants send stake payments to escrow address
- Cleared by EscrowCoordinator after outcome determination

[Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.11 line 736-741, packages/connector/src/agent/coordination/types.ts]

### EscrowCoordinator Implementation

**Class Structure:**

```typescript
interface EscrowCoordinatorConfig {
  ilpAddress: string; // Agent's ILP address for escrow namespacing
  logger: Logger; // Pino logger for structured logging
}

class EscrowCoordinator {
  constructor(config: EscrowCoordinatorConfig) {
    this.config = config;
  }

  generateEscrowAddress(proposalId: string): string {
    return `${this.config.ilpAddress}.escrow.${proposalId}`;
  }

  async requireStake(proposal: Proposal, amount: bigint): Promise<void> {
    const escrowAddress = this.generateEscrowAddress(proposal.id);
    proposal.escrowAddress = escrowAddress;
    proposal.stakes = new Map<string, bigint>();

    this.config.logger.info(
      {
        proposalId: proposal.id,
        amount: amount.toString(),
        escrowAddress,
      },
      'Escrow required for coordination proposal'
    );
  }

  async releaseEscrow(proposal: Proposal, outcome: CoordinationOutcome): Promise<void> {
    if (!proposal.stakeRequired || !proposal.stakes) {
      return; // No escrow to release
    }

    if (outcome === 'approved') {
      this.config.logger.info(
        {
          proposalId: proposal.id,
          outcome,
          escrowAddress: proposal.escrowAddress,
          stakeCount: proposal.stakes.size,
        },
        'Escrow release to recipient (payment logic deferred)'
      );
      // TODO: Future epic - integrate with ILP payment execution
    } else {
      // rejected, expired, inconclusive
      this.config.logger.info(
        {
          proposalId: proposal.id,
          outcome,
          escrowAddress: proposal.escrowAddress,
          stakeCount: proposal.stakes.size,
        },
        'Escrow refund to participants (payment logic deferred)'
      );
      // TODO: Future epic - integrate with ILP payment refunds
    }

    // Clear stakes to mark as processed
    proposal.stakes.clear();
  }
}
```

**Design Philosophy:**

- This story focuses on data model and outcome-based logic
- Actual ILP payment execution is deferred to future epic
- EscrowCoordinator determines WHAT should happen (release vs refund)
- Future integration with AgentWallet or SettlementCoordinator will implement HOW

[Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.11 line 742-761]

### Integration with ResultAggregator

**Modified ResultAggregator.create() flow:**

```typescript
class ResultAggregator {
  constructor(
    private config: ResultAggregatorConfig,
    private escrowCoordinator?: EscrowCoordinator // Optional dependency
  ) {}

  async create(proposal: Proposal, votes: Vote[]): Promise<NostrEvent> {
    // Existing logic: determine outcome using ThresholdConsensus or WeightedVoting
    const outcome = this.determineOutcome(proposal, votes);

    // NEW: Trigger escrow resolution if stake required
    if (proposal.stakeRequired && this.escrowCoordinator) {
      await this.escrowCoordinator.releaseEscrow(proposal, outcome);
    }

    // Existing logic: create Kind 7910 result event
    const resultEvent = this.buildResultEvent(proposal, outcome, votes);
    return resultEvent;
  }
}
```

**Why Optional Dependency:**

- Not all coordination workflows require stake/escrow
- EscrowCoordinator only instantiated when needed
- Backward compatible with existing coordination flows (Stories 20.1-20.10)

[Source: packages/connector/src/agent/coordination/result-aggregator.ts, architecture/coding-standards.md - dependency injection patterns]

### Stake Parameter in propose_coordination Skill

**Updated Skill Parameters:**

```typescript
const ProposeCoordinationParams = z.object({
  // Existing fields...
  type: CoordinationTypeSchema,
  participants: z.array(z.string()),
  description: z.string(),
  // ...

  // NEW: Optional stake requirement
  stakeRequired: z
    .string()
    .optional()
    .describe(
      'Required stake amount in smallest unit (e.g., satoshis for Bitcoin, drops for XRP). ' +
        'If specified, participants must stake this amount to the escrow address before voting.'
    ),
});
```

**AI Skill Execution:**

1. AI determines coordination requires stake (e.g., "require 1000 satoshi stake from participants")
2. AI invokes propose_coordination skill with `stakeRequired: '1000'`
3. Skill parses string to bigint: `const stake = params.stakeRequired ? BigInt(params.stakeRequired) : undefined`
4. ProposalCreator.create() includes stake tag in Kind 5910 event
5. Participants see stake requirement in proposal event and must send payments to escrow address

**Why String in Zod Schema:**

- AI SDK tools use JSON serialization
- bigint not JSON-serializable (would fail in generateText())
- String representation prevents serialization errors
- Parsed to bigint in skill execute function for internal use

[Source: packages/connector/src/agent/ai/skills/propose-coordination-skill.ts, architecture/ai-agent-skills.md - Zod schema patterns]

### Future Epic Integration Notes

This story implements the escrow data model and outcome determination logic. Future work includes:

**Payment Tracking Integration:**

- Monitor escrow address for incoming ILP Prepare packets
- Populate `proposal.stakes` Map when participants send payments
- Validate stake amounts match `proposal.stakeRequired`
- Integration with AgentWallet or EventDatabase to track payment events

**Payment Execution Integration:**

- Implement actual ILP payment send for "release to recipient" scenario
- Implement ILP refund payments for "refund to participants" scenario
- Integration with SettlementCoordinator or AgentChannelManager for payment execution
- Error handling for payment failures (e.g., recipient unreachable, insufficient channel capacity)

**Security Considerations:**

- Payment validation: Ensure stakes are locked (not double-spent) during coordination
- Participant verification: Verify payment sender matches participant pubkey
- Expiration handling: Automatic refund if proposal expires before stakes collected

**Performance Considerations:**

- Escrow address monitoring: Efficient polling or event-driven detection
- Payment batching: Combine multiple refunds into single transaction if supported by settlement layer

[Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.11, architecture/agent-society-protocol.md - payment semantics]

### Error Handling Strategy

**Escrow-Specific Errors:**

- **Invalid Stake Amount**: Validate stake is positive bigint
- **Missing Escrow Address**: Log error if escrow required but address not generated
- **Duplicate Stake Processing**: Check if stakes already cleared before processing
- **Outcome Mismatch**: Validate outcome is valid CoordinationOutcome enum value

**Error Code Usage:**

- No ILP error codes for this story (internal coordination logic, not packet rejection)
- Log errors with logger.error() for observability
- Future integration: ILP payment failures will use T00 (temporary) or F99 (final) error codes

**Try-Catch Pattern:**

```typescript
async releaseEscrow(proposal: Proposal, outcome: CoordinationOutcome): Promise<void> {
  try {
    if (!proposal.stakeRequired) return;

    // Escrow resolution logic...

  } catch (error) {
    this.config.logger.error({
      error,
      proposalId: proposal.id,
      outcome,
    }, 'Failed to release escrow');
    // Do not throw - escrow failure should not block result event creation
  }
}
```

[Source: architecture/error-handling-strategy.md, packages/connector/src/agent/coordination/result-aggregator.ts - error handling patterns]

### Logging Standards

Use Pino logger for structured logging following project conventions:

**Logger Methods:**

- `logger.info()`: Successful operations (escrow created, released, refunded)
- `logger.error()`: Errors and failures (escrow resolution failed)
- `logger.debug()`: Verbose debugging (stake tracking details)

**Structured Log Examples:**

```typescript
// Escrow creation
logger.info(
  {
    proposalId: proposal.id,
    amount: amount.toString(),
    escrowAddress,
    participantCount: proposal.participants.length,
  },
  'Escrow required for coordination proposal'
);

// Escrow release (approved)
logger.info(
  {
    proposalId: proposal.id,
    outcome: 'approved',
    escrowAddress: proposal.escrowAddress,
    stakeCount: proposal.stakes.size,
    totalStaked: Array.from(proposal.stakes.values())
      .reduce((a, b) => a + b, 0n)
      .toString(),
  },
  'Escrow release to recipient'
);

// Escrow refund (rejected/expired)
logger.info(
  {
    proposalId: proposal.id,
    outcome,
    escrowAddress: proposal.escrowAddress,
    refundCount: proposal.stakes.size,
  },
  'Escrow refund to participants'
);
```

**Why Structured Logging:**

- Enables querying logs by proposal ID, outcome, escrow address
- Correlates escrow operations with coordination events
- Supports observability and debugging in multi-agent workflows
- bigint values converted to string for JSON serialization

[Source: architecture/coding-standards.md - logging rules, architecture/error-handling-strategy.md#logging-standards]

### Testing Strategy

**Test Coverage Requirements:**

- Connector package: >80% line coverage
- Coordination module currently: 85-95% coverage
- Target for escrow-coordinator.test.ts: >85% coverage

**Test Categories:**

1. **Escrow Address Generation** (AC 1): Verify address format and uniqueness
2. **Stake Requirement** (AC 1, 2): Test requireStake method with various amounts
3. **Approved Outcome Release** (AC 3): Verify release logic for approved proposals
4. **Rejected Outcome Refund** (AC 4): Verify refund logic for rejected proposals
5. **Expired Outcome Refund** (AC 5): Verify refund logic for expired proposals
6. **Inconclusive Outcome Refund**: Verify refund logic for inconclusive results
7. **No-Op for Non-Staked Proposals**: Verify graceful handling when stakeRequired is undefined
8. **Stake Tracking**: Verify stakes Map initialization and clearing
9. **Integration Flow**: End-to-end test with ProposalCreator, EscrowCoordinator, ResultAggregator

**AAA Pattern Example:**

```typescript
it('should release escrow to recipient when outcome is approved', async () => {
  // Arrange
  const escrowCoordinator = new EscrowCoordinator(testConfig);
  const proposal = createTestProposal({
    stakeRequired: 1000n,
    stakes: new Map([
      ['pubkey1', 1000n],
      ['pubkey2', 1000n],
    ]),
  });

  // Act
  await escrowCoordinator.releaseEscrow(proposal, 'approved');

  // Assert
  expect(mockLogger.info).toHaveBeenCalledWith(
    expect.objectContaining({
      proposalId: proposal.id,
      outcome: 'approved',
      escrowAddress: proposal.escrowAddress,
    }),
    expect.stringContaining('release to recipient')
  );
  expect(proposal.stakes.size).toBe(0); // Stakes cleared
});
```

[Source: architecture/test-strategy-and-standards.md, architecture/ai-agent-skills.md#testing-skills]

### File Locations

**Create:**

- `packages/connector/src/agent/coordination/escrow-coordinator.ts`
- `packages/connector/src/agent/coordination/__tests__/escrow-coordinator.test.ts`
- `packages/connector/test/integration/staked-coordination.test.ts`

**Modify:**

- `packages/connector/src/agent/coordination/types.ts` (add stake fields to Proposal)
- `packages/connector/src/agent/coordination/proposal.ts` (add stake tag support)
- `packages/connector/src/agent/coordination/proposal-parser.ts` (parse stake tag)
- `packages/connector/src/agent/coordination/result-aggregator.ts` (integrate escrow resolution)
- `packages/connector/src/agent/ai/skills/propose-coordination-skill.ts` (add stakeRequired parameter)
- `packages/connector/src/agent/coordination/types.test.ts` (add stake tests)

[Source: architecture/source-tree.md - coordination module structure]

### Project Structure Notes

The escrow-coordinator.ts file follows the existing coordination module pattern:

- Located in `packages/connector/src/agent/coordination/` alongside proposal.ts, vote.ts, result-aggregator.ts
- Co-located tests in `__tests__/` subdirectory
- Integration tests in `packages/connector/test/integration/`
- Consistent with established coordination module structure

No conflicts with existing project structure. The escrow functionality is a natural extension of the coordination module.

[Source: architecture/source-tree.md, packages/connector/src/agent/coordination/]

### Technical Constraints

**ILP Integration Deferred:**

- This story implements escrow data model and outcome logic ONLY
- No actual ILP payment execution (send/receive/refund)
- Future epic will integrate with AgentWallet or SettlementCoordinator

**BigInt Serialization:**

- bigint not JSON-serializable by default
- Convert to string for Nostr event tags: `amount.toString()`
- Convert to string for AI skill parameters (Zod schema uses string, parse to bigint)
- Convert to string for Pino logging (JSON serialization)

**TypeScript Version:**

- TypeScript 5.3.3 has full bigint support
- No polyfills or workarounds needed
- Strict mode compatible

**Database Storage:**

- libSQL (SQLite) stores bigint as INTEGER (signed 64-bit)
- For very large amounts exceeding 64-bit, consider TEXT storage with bigint parsing
- Stake amounts typically fit in 64-bit (1 BTC = 10^8 satoshis = ~53 bits)

[Source: architecture/tech-stack.md - TypeScript version, architecture/database-schema.md]

## Testing

### Test File Locations

- `packages/connector/src/agent/coordination/__tests__/escrow-coordinator.test.ts`
- `packages/connector/test/integration/staked-coordination.test.ts`
- `packages/connector/src/agent/coordination/types.test.ts` (update with stake tests)

### Testing Standards

- Jest 29.7.x with TypeScript support
- AAA pattern (Arrange, Act, Assert)
- > 80% coverage for connector package
- Co-located test files with coordination module
  [Source: architecture/test-strategy-and-standards.md]

### Required Test Cases

1. **Escrow Address Generation Tests (AC: 1)**
   - Verify `generateEscrowAddress()` returns correct format
   - Test with various proposal IDs (short, long, special characters)
   - Verify uniqueness based on proposal ID

2. **Require Stake Tests (AC: 1, 2)**
   - Test `requireStake()` initializes escrow address
   - Verify stakes Map initialized
   - Verify logger.info called with correct parameters
   - Test with various stake amounts (small, large, edge cases)

3. **Release Escrow - Approved Tests (AC: 3)**
   - Test `releaseEscrow()` with outcome='approved'
   - Verify "release to recipient" log message
   - Verify stakes Map cleared after release

4. **Release Escrow - Rejected Tests (AC: 4)**
   - Test with outcome='rejected'
   - Verify "refund to participants" log message
   - Verify stakes Map cleared

5. **Release Escrow - Expired Tests (AC: 5)**
   - Test with outcome='expired'
   - Verify refund logic triggered
   - Verify stakes Map cleared

6. **Release Escrow - Inconclusive Tests**
   - Test with outcome='inconclusive'
   - Verify refund logic triggered

7. **No-Op Tests**
   - Test `releaseEscrow()` with proposal without stakeRequired
   - Verify no error, immediate return
   - Verify no logging

8. **Integration Flow Tests (AC: 1-6)**
   - Create staked proposal using ProposalCreator
   - Verify stake tag included in Kind 5910 event
   - Parse proposal with ProposalParser, verify stake extracted
   - Simulate voting and result aggregation
   - Verify EscrowCoordinator.releaseEscrow called by ResultAggregator
   - Verify outcome-based escrow resolution

9. **Proposal Type Tests (AC: 1, 6)**
   - Test Proposal interface with stakeRequired field
   - Test bigint serialization/deserialization
   - Test edge cases: zero stake, negative stake (should fail validation)

10. **Logger Integration Tests**
    - Verify logger.info called on requireStake
    - Verify logger.info called on releaseEscrow
    - Verify structured log includes proposalId, outcome, escrowAddress

## Change Log

| Date       | Version | Description                                                | Author            |
| ---------- | ------- | ---------------------------------------------------------- | ----------------- |
| 2026-01-30 | 0.1     | Initial draft created with comprehensive technical context | Claude Sonnet 4.5 |

---

## Dev Agent Record

### Agent Model Used

[To be filled by Dev Agent]

### Debug Log References

[To be filled by Dev Agent]

### Completion Notes

[To be filled by Dev Agent]

### File List

**Created:**
[To be filled by Dev Agent]

**Modified:**
[To be filled by Dev Agent]

---

## QA Results

[To be filled by QA Agent]
