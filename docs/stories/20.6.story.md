# Story 20.6: Threshold Consensus Implementation

## Status

Done

## Story

**As a** coordinator agent evaluating coordination proposals,
**I want** to implement threshold-based consensus algorithms (threshold, majority, consensus),
**so that** I can determine when proposals are approved, rejected, or pending based on vote tallies and coordination type rules.

## Acceptance Criteria

1. Support `threshold` type requiring N votes to approve
2. Support `majority` type requiring >50%
3. Support `consensus` type requiring all participants
4. Check if threshold reached after each vote
5. Handle quorum requirements
6. Determine outcome: approved, rejected, inconclusive
7. Return outcome when consensus determined (Note: Event emission handled by separate Coordinator class)

## Tasks / Subtasks

- [x] Task 1: Create ThresholdConsensus class file (AC: 1-7)
  - [x] Create `packages/connector/src/agent/coordination/threshold-consensus.ts`
  - [x] Import types from `./types.ts`: Proposal, Vote, CoordinationOutcome, VoteTally, CoordinationType
  - [x] Import constants: COORDINATION_PROPOSAL_KIND
  - [x] Define ThresholdConsensus class (stateless, no constructor dependencies)
  - [x] [Source: architecture/source-tree.md - coordination module structure]

- [x] Task 2: Implement vote tallying method
  - [x] Create `private tallyVotes(votes: Map<string, Vote>): VoteTally` method
  - [x] Count approve, reject, abstain votes from votes Map
  - [x] Return VoteTally object with counts
  - [x] Handle empty votes Map (all zeros)
  - [x] [Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.6 technical notes]

- [x] Task 3: Implement proposal expiration check (AC: 6)
  - [x] Create `private isExpired(proposal: Proposal): boolean` method
  - [x] Compare proposal.expires (Unix timestamp) with current time
  - [x] Return true if current time >= expires
  - [x] Use Math.floor(Date.now() / 1000) for current Unix timestamp
  - [x] [Source: packages/connector/src/agent/coordination/proposal-parser.ts - expiration pattern]

- [x] Task 4: Implement consensus type evaluation (AC: 3)
  - [x] Create `private evaluateConsensus(proposal: Proposal, votes: Map<string, Vote>, tally: VoteTally): CoordinationOutcome | 'pending'`
  - [x] Consensus requires ALL participants to approve
  - [x] If tally.approve === proposal.participants.length, return 'approved'
  - [x] If tally.reject > 0, return 'rejected' (any rejection fails consensus)
  - [x] If not all voted, check expiration: expired → 'inconclusive', else → 'pending'
  - [x] [Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.6 line 455-458]

- [x] Task 5: Implement majority type evaluation (AC: 2)
  - [x] Create `private evaluateMajority(proposal: Proposal, votes: Map<string, Vote>, tally: VoteTally): CoordinationOutcome | 'pending'`
  - [x] Majority requires >50% approval
  - [x] Calculate majority threshold: Math.floor(proposal.participants.length / 2) + 1
  - [x] If tally.approve >= majority, return 'approved'
  - [x] If tally.reject >= majority, return 'rejected'
  - [x] If all voted but no majority reached, return 'inconclusive'
  - [x] If not all voted and not expired, return 'pending'
  - [x] [Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.6 line 460-464]

- [x] Task 6: Implement threshold type evaluation (AC: 1, 4)
  - [x] Create `private evaluateThreshold(proposal: Proposal, votes: Map<string, Vote>, tally: VoteTally): CoordinationOutcome | 'pending'`
  - [x] Threshold requires N votes to approve (N from proposal.threshold or default to majority)
  - [x] Get threshold: proposal.threshold ?? Math.floor(proposal.participants.length / 2) + 1
  - [x] If tally.approve >= threshold, return 'approved'
  - [x] Calculate remaining votes: proposal.participants.length - votes.size
  - [x] If tally.approve + remaining < threshold, return 'rejected' (impossible to reach threshold)
  - [x] Else return 'pending'
  - [x] [Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.6 line 466-471]

- [x] Task 7: Implement quorum check (AC: 5)
  - [x] Create `private checkQuorum(proposal: Proposal, votes: Map<string, Vote>): 'met' | 'pending' | 'failed'`
  - [x] If proposal.quorum is undefined, return 'met' (no quorum required)
  - [x] If votes.size >= proposal.quorum, return 'met'
  - [x] If proposal expired and votes.size < quorum, return 'failed'
  - [x] Else return 'pending'
  - [x] [Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.6 line 446-451]

- [x] Task 8: Implement main evaluate() method (AC: 1-7)
  - [x] Create `evaluate(proposal: Proposal, votes: Map<string, Vote>): CoordinationOutcome | 'pending'` method signature
  - [x] Tally votes using tallyVotes()
  - [x] Check quorum using checkQuorum()
  - [x] If quorum failed, return 'inconclusive'
  - [x] If quorum pending and not expired, return 'pending'
  - [x] Route to appropriate evaluation method based on proposal.type:
    - [x] 'consensus' → evaluateConsensus()
    - [x] 'majority' → evaluateMajority()
    - [x] 'threshold' → evaluateThreshold()
  - [x] Throw UnsupportedCoordinationTypeError for 'ranked' or 'allocation' (not implemented in this story)
  - [x] Return outcome or 'pending'
  - [x] [Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.6 line 441-476]

- [x] Task 9: Verify UnsupportedCoordinationTypeError exists (AC: 1-7)
  - [x] Verify error class exists in types.ts (line 411-416)
  - [x] Confirm constructor takes coordination type as parameter
  - [x] Confirm error message format: "Unsupported coordination type: ${type}"
  - [x] Confirm error name is 'UnsupportedCoordinationTypeError'
  - [x] Verify it's exported from types.ts
  - [x] [Source: packages/connector/src/agent/coordination/types.ts:411-416]

- [x] Task 10: Update coordination index exports
  - [x] Add `export { ThresholdConsensus } from './threshold-consensus';` to coordination/index.ts
  - [x] Verify VoteTally interface exported from types
  - [x] Verify UnsupportedCoordinationTypeError exported from types
  - [x] [Source: architecture/source-tree.md - module exports pattern]

- [x] Task 11: Create comprehensive unit tests (AC: 1-7)
  - [x] Create `packages/connector/src/agent/coordination/threshold-consensus.test.ts`
  - [x] Import ThresholdConsensus, ProposalCreator, VoteCreator, all types, test utilities
  - [x] Use nostr-tools generateSecretKey for test keys
  - [x] Test consensus type: all approve → approved
  - [x] Test consensus type: one reject → rejected
  - [x] Test consensus type: not all voted → pending
  - [x] Test consensus type: expired without all votes → inconclusive
  - [x] Test majority type: >50% approve → approved
  - [x] Test majority type: >50% reject → rejected
  - [x] Test majority type: split vote (no majority) → inconclusive
  - [x] Test majority type: not all voted → pending
  - [x] Test threshold type: reach threshold → approved
  - [x] Test threshold type: impossible to reach threshold → rejected
  - [x] Test threshold type: not all voted → pending
  - [x] Test threshold type with custom threshold value
  - [x] Test threshold type with default threshold (majority)
  - [x] Test quorum: met → evaluate normally
  - [x] Test quorum: pending (not expired) → pending
  - [x] Test quorum: failed (expired without quorum) → inconclusive
  - [x] Test quorum: undefined (no requirement) → evaluate normally
  - [x] Test proposal expired with split votes → inconclusive
  - [x] Test unsupported coordination type 'ranked' → throws error
  - [x] Test unsupported coordination type 'allocation' → throws error
  - [x] Test empty votes map → pending
  - [x] Use AAA pattern (Arrange, Act, Assert)
  - [x] Achieve >80% code coverage
  - [x] [Source: architecture/test-strategy-and-standards.md - unit test requirements]

- [x] Task 12: Run tests and verify
  - [x] Run `npm test -- threshold-consensus.test.ts` in connector package
  - [x] Verify all tests pass
  - [x] Check coverage meets 80% requirement
  - [x] Fix any TypeScript strict mode errors
  - [x] Fix any ESLint errors

## Dev Notes

### Previous Story Insights (20.5)

From Story 20.5 Dev Agent Record:

- VoteParser implemented with comprehensive validation and 95% test coverage
- Security-first design with signature verification and authorization validation
- Participant validation pattern established: throw NotParticipantError if not in participants list
- E tag format uses NIP-10 convention with 'proposal' marker for event references
- Stateless class design with private helper methods for specific validation tasks
- JSDoc comments on all methods explaining purpose and parameters
- Error messages include context for debugging (invalid values, proposal IDs, pubkeys)
- Critical nostr-tools upgrade from 2.10.0 → 2.20.0 to fix verifyEvent() bug
  [Source: docs/stories/20.5.story.md#dev-agent-record]

### Consensus Algorithm Overview

The ThresholdConsensus class evaluates vote tallies to determine proposal outcomes based on coordination type rules:

**Consensus Type:** All participants must approve for approval. Any rejection immediately fails the proposal.

- Approved: tally.approve === total participants
- Rejected: tally.reject > 0
- Pending: not all voted and not expired
- Inconclusive: expired without full approval

**Majority Type:** More than 50% must approve or reject for definitive outcome.

- Approved: tally.approve >= Math.floor(total / 2) + 1
- Rejected: tally.reject >= Math.floor(total / 2) + 1
- Pending: not all voted and no majority reached
- Inconclusive: all voted but no majority reached

**Threshold Type:** N votes required for approval (N from proposal.threshold or default to majority).

- Approved: tally.approve >= threshold
- Rejected: impossible to reach threshold (approve + remaining < threshold)
- Pending: threshold not reached but still possible

**Quorum Requirements:** Minimum participation required before evaluating outcome.

- If quorum not met and proposal expired → Inconclusive
- If quorum not met and not expired → Pending
- If quorum met → Evaluate normally based on coordination type

[Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.6 technical notes]

### VoteTally Interface

```typescript
interface VoteTally {
  approve: number;
  reject: number;
  abstain: number;
}
```

The tallyVotes() method constructs this interface by counting votes in the votes Map.
[Source: packages/connector/src/agent/coordination/types.ts:224-228]

### Proposal Interface Reference

```typescript
interface Proposal {
  kind: 5910;
  id: string;
  type: CoordinationType;
  participants: string[]; // Total participant count
  threshold?: number; // Custom threshold for threshold type
  quorum?: number; // Minimum participation required
  expires: number; // Unix timestamp for expiration
  action?: ProposalAction;
  weights?: Map<string, number>;
  content: string;
  event: NostrEvent;
}
```

Key fields for consensus evaluation:

- `participants.length` - Total number of participants
- `threshold` - Required votes for threshold type (optional, defaults to majority)
- `quorum` - Minimum participation required (optional)
- `expires` - Unix timestamp to check if proposal expired
- `type` - Coordination type determines evaluation algorithm
  [Source: packages/connector/src/agent/coordination/types.ts:162-186]

### CoordinationOutcome Type

```typescript
type CoordinationOutcome = 'approved' | 'rejected' | 'expired' | 'inconclusive';
```

Note: The evaluate() method can also return `'pending'` (not a CoordinationOutcome) to indicate evaluation is not yet complete.

**Return Value Guidelines:**

- `'approved'` - Threshold reached for approval
- `'rejected'` - Threshold reached for rejection or impossible to approve
- `'inconclusive'` - Proposal expired without reaching threshold
- `'pending'` - Evaluation incomplete (not all votes received, quorum not met)

[Source: packages/connector/src/agent/coordination/types.ts:98]

### Expiration Checking Pattern

Follow the expiration pattern from ProposalParser:

```typescript
private isExpired(proposal: Proposal): boolean {
  const now = Math.floor(Date.now() / 1000); // Unix timestamp (seconds)
  return now > proposal.expires;
}
```

Use this method to determine if proposal has expired when evaluating pending outcomes.
[Source: packages/connector/src/agent/coordination/proposal-parser.ts:137-142]

### UnsupportedCoordinationTypeError

This story implements consensus, majority, and threshold types. Ranked and allocation types are deferred to future stories.

```typescript
export class UnsupportedCoordinationTypeError extends Error {
  constructor(type: string) {
    super(`Coordination type '${type}' is not supported`);
    this.name = 'UnsupportedCoordinationTypeError';
  }
}
```

Throw this error when evaluate() receives 'ranked' or 'allocation' type.
[Source: docs/prd/epic-20-multi-agent-coordination.md - Story 20.6 line 474]

### Stateless Class Design

ThresholdConsensus should have NO constructor dependencies (stateless class):

```typescript
export class ThresholdConsensus {
  // No constructor needed

  evaluate(proposal: Proposal, votes: Map<string, Vote>): CoordinationOutcome | 'pending' {
    // All logic uses parameters passed in
  }

  private tallyVotes(votes: Map<string, Vote>): VoteTally {
    // Pure function - no instance state
  }

  private isExpired(proposal: Proposal): boolean {
    // Pure function - no instance state
  }

  // ... more private helper methods
}
```

This design makes the class easy to test (no mocking) and safe for concurrent use.
[Source: packages/connector/src/agent/coordination/proposal-parser.ts - stateless pattern]

### Test Data Generation

Use ProposalCreator and VoteCreator to generate test data:

```typescript
describe('ThresholdConsensus', () => {
  let consensus: ThresholdConsensus;
  let proposalCreator: ProposalCreator;
  let coordinatorPrivateKeyHex: string;
  let voter1PrivateKeyHex: string;
  let voter2PrivateKeyHex: string;
  let voter1Pubkey: string;
  let voter2Pubkey: string;

  beforeEach(() => {
    consensus = new ThresholdConsensus();

    const coordinatorPrivateKey = generateSecretKey();
    coordinatorPrivateKeyHex = bytesToHex(coordinatorPrivateKey);
    proposalCreator = new ProposalCreator(coordinatorPrivateKeyHex);

    const voter1PrivateKey = generateSecretKey();
    voter1PrivateKeyHex = bytesToHex(voter1PrivateKey);
    voter1Pubkey = getPublicKey(voter1PrivateKey);

    const voter2PrivateKey = generateSecretKey();
    voter2PrivateKeyHex = bytesToHex(voter2PrivateKey);
    voter2Pubkey = getPublicKey(voter2PrivateKey);
  });

  it('should approve when consensus reached (all approve)', () => {
    // Arrange: Create proposal with 2 participants
    const proposalEvent = proposalCreator.create({
      type: 'consensus',
      participants: [voter1Pubkey, voter2Pubkey],
      expiresIn: 3600,
      description: 'Test consensus',
    });
    const proposal = proposalCreator.toProposal(proposalEvent);

    // Create votes from both participants (approve)
    const voteCreator1 = new VoteCreator(voter1PrivateKeyHex);
    const vote1Event = voteCreator1.create({ proposal, vote: 'approve' });
    const vote1 = voteCreator1.toVote(vote1Event);

    const voteCreator2 = new VoteCreator(voter2PrivateKeyHex);
    const vote2Event = voteCreator2.create({ proposal, vote: 'approve' });
    const vote2 = voteCreator2.toVote(vote2Event);

    const votes = new Map<string, Vote>([
      [voter1Pubkey, vote1],
      [voter2Pubkey, vote2],
    ]);

    // Act: Evaluate consensus
    const outcome = consensus.evaluate(proposal, votes);

    // Assert: Should be approved
    expect(outcome).toBe('approved');
  });
});
```

[Source: packages/connector/src/agent/coordination/vote.test.ts - test setup pattern]

### File Locations

- Create: `packages/connector/src/agent/coordination/threshold-consensus.ts`
- Create: `packages/connector/src/agent/coordination/threshold-consensus.test.ts`
- Update: `packages/connector/src/agent/coordination/types.ts` (add UnsupportedCoordinationTypeError if missing)
- Update: `packages/connector/src/agent/coordination/index.ts` (add ThresholdConsensus export)
  [Source: architecture/source-tree.md - coordination module]

### Edge Cases to Test

1. **Empty votes map:** Should return 'pending'
2. **Expired proposal with no votes:** Should return 'inconclusive'
3. **Expired proposal with split votes:** Should return 'inconclusive'
4. **Quorum not met but not expired:** Should return 'pending'
5. **Quorum not met and expired:** Should return 'inconclusive'
6. **All participants abstain:** Should return 'inconclusive' (no approve/reject majority)
7. **Custom threshold value:** Should use proposal.threshold instead of default majority
8. **Threshold type with remaining votes:** Should return 'pending' if threshold still possible
9. **Threshold type impossible to reach:** Should return 'rejected' when approve + remaining < threshold
10. **Unsupported coordination types:** Should throw UnsupportedCoordinationTypeError for 'ranked' and 'allocation'

## Testing

### Test File Location

`packages/connector/src/agent/coordination/threshold-consensus.test.ts`

### Testing Standards

- Jest 29.7.x with TypeScript support
- AAA pattern (Arrange, Act, Assert)
- > 80% coverage for connector package
- Co-located test files with source
  [Source: architecture/test-strategy-and-standards.md]

### Required Test Cases

1. **Consensus Type Tests (AC: 3)**
   - All participants approve → 'approved'
   - One participant rejects → 'rejected'
   - Not all voted and not expired → 'pending'
   - Expired without full consensus → 'inconclusive'

2. **Majority Type Tests (AC: 2)**
   - > 50% approve → 'approved'
   - > 50% reject → 'rejected'
   - Split vote (no majority) with all votes → 'inconclusive'
   - Not all voted and not expired → 'pending'
   - Expired without majority → 'inconclusive'

3. **Threshold Type Tests (AC: 1, 4)**
   - Reach threshold (approve >= N) → 'approved'
   - Impossible to reach threshold → 'rejected'
   - Not all voted but threshold possible → 'pending'
   - Custom threshold value used correctly
   - Default threshold (majority) when none specified

4. **Quorum Tests (AC: 5)**
   - Quorum met → evaluates normally
   - Quorum not met and not expired → 'pending'
   - Quorum not met and expired → 'inconclusive'
   - No quorum requirement (undefined) → evaluates normally

5. **Edge Cases**
   - Empty votes map → 'pending'
   - All participants abstain → depends on coordination type
   - Expired proposal with votes → 'inconclusive'
   - Unsupported coordination types → throws error

6. **VoteTally Tests**
   - Correctly counts approve votes
   - Correctly counts reject votes
   - Correctly counts abstain votes
   - Handles empty votes map

7. **Expiration Tests**
   - Detects expired proposals correctly
   - Detects active proposals correctly
   - Uses Unix timestamp comparison

## Change Log

| Date       | Version | Description                                                                                                                | Author            |
| ---------- | ------- | -------------------------------------------------------------------------------------------------------------------------- | ----------------- |
| 2026-01-29 | 0.1     | Initial draft                                                                                                              | SM Agent          |
| 2026-01-29 | 0.2     | Validation fixes: clarified AC 7 scope, fixed expiration operator (>= to >), updated Task 9 to verify existing error class | Claude Sonnet 4.5 |

---

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

None - implementation completed without issues requiring debug logging.

### Completion Notes

Successfully implemented ThresholdConsensus class with all three coordination types (consensus, majority, threshold) and comprehensive test coverage.

**Implementation Highlights:**

- Stateless class design with pure functions for easy testing and concurrent use
- 96.82% test coverage (26 passing tests) exceeding 80% requirement
- Proper handling of quorum requirements and proposal expiration
- Type-safe exhaustiveness checking for coordination types
- Follows AAA test pattern with ProposalCreator and VoteCreator for test data generation

**Key Design Decisions:**

- Used TypeScript exhaustiveness checking in default case to ensure all coordination types handled
- Implemented separate evaluation methods for each coordination type for clarity
- Quorum check happens before type-specific evaluation to short-circuit expired/failed quorums
- Threshold type defaults to majority calculation when custom threshold not specified

**Test Coverage:**

- Consensus type: 5 test cases
- Majority type: 5 test cases
- Threshold type: 5 test cases
- Quorum requirements: 4 test cases
- Edge cases: 5 test cases
- Unsupported types: 2 test cases

**Issues Resolved:**

- Fixed unused import warnings (removed COORDINATION_PROPOSAL_KIND, Proposal from imports)
- Fixed ESLint no-case-declarations error by wrapping default case in braces
- Updated test strategy to manually expire proposals (ProposalCreator validates expiresIn > 0)

All acceptance criteria met. Ready for QA review.

### File List

**New Files:**

- `packages/connector/src/agent/coordination/threshold-consensus.ts` - ThresholdConsensus implementation
- `packages/connector/src/agent/coordination/threshold-consensus.test.ts` - Unit tests (26 tests, 96.82% coverage)

**Modified Files:**

- `packages/connector/src/agent/coordination/index.ts` - Added ThresholdConsensus export

---

## QA Results

### Review Date: 2026-01-29

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Exceptional implementation quality.** The ThresholdConsensus class demonstrates professional software engineering with stateless design, pure functions, comprehensive documentation, and exhaustive test coverage. The implementation perfectly follows the technical specifications from the PRD and adheres to all project coding standards.

**Highlights:**

- Stateless class design enables easy testing and concurrent use
- TypeScript exhaustiveness checking ensures all coordination types are handled
- 96.82% test coverage with 26 comprehensive test cases (exceeds 80% requirement)
- Clear separation of concerns with dedicated evaluation methods per coordination type
- Proper error handling using domain-specific error classes

### Refactoring Performed

No refactoring needed. The code is already well-structured and follows best practices.

### Compliance Check

- Coding Standards: ✓ Fully compliant
  - TypeScript strict mode enabled
  - Proper naming conventions (kebab-case files, camelCase methods, PascalCase classes)
  - No console.log usage (Pino logger would be used if needed)
  - JSDoc comments on all public and private methods
- Project Structure: ✓ Fully compliant
  - Co-located tests (threshold-consensus.test.ts)
  - Proper module exports via coordination/index.ts
  - Follows source tree structure for coordination module
- Testing Strategy: ✓ Fully compliant
  - Jest 29.7.x with TypeScript support
  - AAA pattern (Arrange, Act, Assert) in all tests
  - > 80% coverage requirement met (96.82%)
  - Proper test data generation using ProposalCreator and VoteCreator
  - No testing anti-patterns (inline bind, insufficient timeouts, mock leakage)
- All ACs Met: ✓ All 7 acceptance criteria fully implemented and tested

### Improvements Checklist

All implementation requirements met. No improvements needed.

- [x] Implement consensus type evaluation (AC 3)
- [x] Implement majority type evaluation (AC 2)
- [x] Implement threshold type evaluation (AC 1, 4)
- [x] Implement quorum checking (AC 5)
- [x] Determine outcomes correctly (AC 6)
- [x] Handle expiration logic properly
- [x] Comprehensive test coverage (26 tests, 96.82% coverage)

### Security Review

**PASS** - No security concerns identified.

- Input validation handled by caller (ProposalParser, VoteParser)
- No external dependencies or I/O operations
- Pure functions with deterministic behavior
- Proper error handling prevents undefined behavior

### Performance Considerations

**PASS** - Excellent performance characteristics.

- O(n) time complexity for vote tallying (single pass over votes Map)
- O(1) space complexity (small fixed-size VoteTally object)
- No allocations in hot path beyond tally object
- Stateless design enables concurrent evaluation without locks
- Early returns optimize common cases (threshold reached, quorum failed)

### Files Modified During Review

None. No modifications needed.

### Gate Status

Gate: **PASS** → docs/qa/gates/20.6-threshold-consensus-implementation.yml

### Requirements Traceability

All acceptance criteria fully implemented and tested:

| AC  | Requirement                                         | Implementation                                      | Test Coverage   |
| --- | --------------------------------------------------- | --------------------------------------------------- | --------------- |
| 1   | Support threshold type requiring N votes            | evaluateThreshold() method                          | ✓ 5 test cases  |
| 2   | Support majority type requiring >50%                | evaluateMajority() method                           | ✓ 5 test cases  |
| 3   | Support consensus type requiring all participants   | evaluateConsensus() method                          | ✓ 5 test cases  |
| 4   | Check if threshold reached after each vote          | evaluate() method called per vote                   | ✓ Tested        |
| 5   | Handle quorum requirements                          | checkQuorum() method                                | ✓ 4 test cases  |
| 6   | Determine outcome: approved, rejected, inconclusive | All evaluation methods return correct outcomes      | ✓ All scenarios |
| 7   | Return outcome when consensus determined            | evaluate() returns CoordinationOutcome or 'pending' | ✓ Tested        |

**Given-When-Then Traceability:**

**AC 1: Threshold Type**

- **Given** a proposal with threshold type and threshold=2
- **When** 2 participants approve
- **Then** outcome is 'approved'
- **Test:** threshold-consensus.test.ts:351-381

**AC 2: Majority Type**

- **Given** a proposal with 3 participants (majority type)
- **When** 2 approve and 1 rejects (>50%)
- **Then** outcome is 'approved'
- **Test:** threshold-consensus.test.ts:191-225

**AC 3: Consensus Type**

- **Given** a proposal requiring consensus from 2 participants
- **When** all 2 approve
- **Then** outcome is 'approved'
- **Test:** threshold-consensus.test.ts:46-75

**AC 4: Threshold Checking**

- **Given** a proposal with threshold=3 of 3
- **When** 1 approves and 2 reject (impossible to reach threshold)
- **Then** outcome is 'rejected'
- **Test:** threshold-consensus.test.ts:383-413

**AC 5: Quorum Requirements**

- **Given** a proposal with quorum=2
- **When** only 1 vote received and not expired
- **Then** outcome is 'pending'
- **Test:** threshold-consensus.test.ts:535-558

**AC 6: Outcome Determination**

- **Given** various proposal states
- **When** evaluated based on votes and expiration
- **Then** correct outcome returned (approved, rejected, inconclusive, pending)
- **Tests:** All 26 test cases validate outcome logic

**AC 7: Return Outcome**

- **Given** any proposal evaluation
- **When** evaluate() is called
- **Then** returns CoordinationOutcome or 'pending' as appropriate
- **Tests:** All test cases validate return values

### Recommended Status

**✓ Ready for Done** - All acceptance criteria met, no issues identified. Implementation is production-ready.
